# ema_backtest_simulator.py
#
# Description:
# A comprehensive backtesting simulator for the "5-EMA Manny" mean-reversion
# scalping strategy. This script is designed to work with the 15-minute
# processed data generated by the 'universal_calculate_indicators.py' script.
#
# MODIFICATION (v37 - Final Audit Fixes):
# - Fixed a critical bug in the ATR trailing stop logic that prevented it from working.
# - Corrected the "Time in Market" calculation to prevent double-counting and values > 100%.

import pandas as pd
import numpy as np
import os
import sys
import math
from scipy.signal import argrelextrema
from datetime import datetime

# --- PATH CONFIGURATION ---
script_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(script_dir)

# --- HELPER FUNCTION ---
def format_config_for_summary(cfg):
    """Formats the config dictionary into a readable string for the summary report."""
    output = []
    for key, value in cfg.items():
        if isinstance(value, dict):
            output.append(f"\n[{key.replace('_', ' ').title()}]")
            for sub_key, sub_value in value.items():
                output.append(f"  {sub_key}: {sub_value}")
        else:
            output.append(f"{key}: {value}")
    return "\n".join(output)

# --- STRATEGY CONFIGURATION ---
CONFIG = {
    # --- General Backtest Parameters ---
    "strategy_name": "5_EMA_Manny_Reversal",
    "instruments": ["NIFTYBANK-INDEX", "NIFTY50-INDEX"],
    "data_timeframe": "15min",
    "strategy_timeframe": "15min",
    "backtest_start_date": "2024-01-01",
    "backtest_end_date": "2024-12-31",
    "trade_direction": "both",
    "trade_mode": "intraday",

    # --- Portfolio & Risk Configuration ---
    "initial_capital": 500000,
    "use_compounding": False,
    "portfolio_risk": {
        "max_portfolio_risk_percent": 2.0,
    },
    "instrument_details": {
        "NIFTYBANK-INDEX": {"lot_size": 30, "max_contracts_per_trade": 10},
        "NIFTY50-INDEX": {"lot_size": 75, "max_contracts_per_trade": 4},
    },
    "position_sizing": { "risk_per_trade_percent": 1.0 },

    # --- Strategy-Specific Settings ---
    "ema_period": 5,
    "rsi_period": 14,
    "volume_sma_period": 20,
    "risk_reward_ratio": 5.0,
    "trading_window_start": "10:00",
    "trading_window_end": "15:00",
    "alert_candle_expiry": 1,
    "divergence_lookback": 30,

    # --- Stop-Loss Configuration ---
    "stop_loss": {
        "use_two_candle_sl": True,
        "minimum_sl_points": {
            "NIFTYBANK-INDEX": 40.0,
            "NIFTY50-INDEX": 25.0,
        },
        "use_breakeven_stop": False,
        "breakeven_profit_buffer_points": 2.0,
        "breakeven_cost_assumption_points": 2.0, 
        "use_atr_trail": True,
        "atr_trail_period": 14,
        "atr_trail_multiplier": 4.0,
    },

    # --- Realism & Costs ---
    "transaction_costs": {
        "slippage_points": 0.5,
        "cost_per_trade_points": { 
            "NIFTYBANK-INDEX": 14.0,
            "NIFTY50-INDEX": 7.0,
        },
    },
    "advanced_slippage": {
        "enabled": True,
        "slippage_per_contract_points": 0.1
    },

    # --- Confluence Filter Controls ---
    "use_rsi_divergence": True,
    "use_volume_profile": True,
    "use_static_sr": True,
    "min_confluence_filters": 0,

    # --- Logging & File Paths ---
    "log_level": "trades",
    "input_data_dir": os.path.join(project_root, "data", "universal_processed"),
    "log_folder": os.path.join(project_root, "backtest_logs"),
    "log_options": { "log_trades": True, "log_summary": True },
}

class EMABacktester:
    def __init__(self, config):
        self.config = config
        self.trade_log = []
        self.all_data = {}
        self.master_dates = self._load_and_filter_data()
        self.log_level = self.config.get('log_level', 'trades')
        self.equity = self.config['initial_capital']

    def _load_and_filter_data(self):
        base_path = os.path.join(self.config["input_data_dir"], self.config["data_timeframe"])
        master_dates = set()

        for instrument in self.config['instruments']:
            filename = f"{instrument}_{self.config['data_timeframe']}_with_indicators.csv"
            full_path = os.path.join(base_path, filename)
            if not os.path.exists(full_path):
                print(f"WARNING: Data file not found for {instrument}. Skipping.")
                continue
            
            df = pd.read_csv(full_path, index_col='datetime', parse_dates=True)
            start_date = self.config.get("backtest_start_date")
            end_date = self.config.get("backtest_end_date")
            if start_date: df = df[df.index >= pd.to_datetime(start_date)]
            if end_date: df = df[df.index <= pd.to_datetime(end_date)]

            df['prev_day_high'] = df['high'].shift(1).resample('D').max().ffill()
            df['prev_day_low'] = df['low'].shift(1).resample('D').min().ffill()
            
            self.all_data[instrument] = df
            master_dates.update(df.index)
            print(f"Successfully loaded {len(df)} data points for {instrument}.")

        if not self.all_data:
            print("FATAL ERROR: No data loaded for any instruments. Exiting.")
            return []

        sorted_dates = sorted(list(master_dates))
        print(f"\nBacktest Period: {sorted_dates[0].strftime('%Y-%m-%d')} to {sorted_dates[-1].strftime('%Y-%m-%d')}")
        return sorted_dates

    def _find_divergence(self, price, indicator, order=5):
        price_peaks = argrelextrema(price.values, np.greater, order=order)[0]
        indicator_peaks = argrelextrema(indicator.values, np.greater, order=order)[0]
        price_troughs = argrelextrema(price.values, np.less, order=order)[0]
        indicator_troughs = argrelextrema(indicator.values, np.less, order=order)[0]
        if len(price_peaks) >= 2 and len(indicator_peaks) >= 2:
            if price.iloc[price_peaks[-1]] > price.iloc[price_peaks[-2]] and indicator.iloc[indicator_peaks[-1]] < indicator.iloc[indicator_peaks[-2]]:
                return "Bearish"
        if len(price_troughs) >= 2 and len(indicator_troughs) >= 2:
            if price.iloc[price_troughs[-1]] < price.iloc[price_troughs[-2]] and indicator.iloc[indicator_troughs[-1]] > indicator.iloc[indicator_troughs[-2]]:
                return "Bullish"
        return "None"

    def run_backtest(self):
        if not self.master_dates: return
        
        positions = {}
        active_alerts = {}
        print("\n--- Starting Backtest Simulation ---")
        
        for i in range(2, len(self.master_dates)):
            current_time = self.master_dates[i]
            prev_time = self.master_dates[i-1]
            
            if self.log_level != 'silent':
                progress_str = f"Processing: {current_time.date()} | Trades: {len(self.trade_log)} | Equity: Rs.{self.equity:,.2f}"
                sys.stdout.write(f"\r{progress_str.ljust(80)}")
                sys.stdout.flush()

            for symbol, trade in list(positions.items()):
                if symbol not in self.all_data or current_time not in self.all_data[symbol].index: continue
                
                current_candle = self.all_data[symbol].loc[current_time]
                prev_candle = self.all_data[symbol].loc[prev_time] if prev_time in self.all_data[symbol].index else None

                if prev_candle is not None and current_candle.name.date() > prev_candle.name.date():
                    exit_reason = self._handle_overnight_gap(trade, current_candle)
                    if exit_reason:
                        self._close_trade(trade, current_candle, exit_reason, is_gap_exit=True)
                        positions.pop(symbol)
                        active_alerts.pop(symbol, None)
                        continue

                if prev_candle is not None: self._manage_open_trade(trade, prev_candle, current_candle)
                exit_reason = self._check_for_exit(trade, current_candle)
                if exit_reason:
                    self._close_trade(trade, current_candle, exit_reason)
                    positions.pop(symbol)
                    active_alerts.pop(symbol, None)
            
            is_in_trading_window = prev_time.strftime('%H:%M') >= self.config['trading_window_start'] and \
                                   prev_time.strftime('%H:%M') < self.config['trading_window_end']

            if is_in_trading_window:
                for symbol in self.config['instruments']:
                    if symbol in positions or symbol not in self.all_data or prev_time not in self.all_data[symbol].index:
                        continue

                    new_alert = self._find_alert_candle(symbol, prev_time)
                    if new_alert:
                        active_alerts[symbol] = new_alert
                    
                    if symbol in active_alerts:
                        alert = active_alerts[symbol]
                        prev_candle_index = self.all_data[symbol].index.get_loc(prev_time)
                        alert_candle_index = self.all_data[symbol].index.get_loc(alert['candle_time'])
                        
                        if prev_candle_index - alert_candle_index >= self.config['alert_candle_expiry']:
                            active_alerts.pop(symbol, None)
                        else:
                            if current_time in self.all_data[symbol].index:
                                current_candle = self.all_data[symbol].loc[current_time]
                                trade_entry = self._check_for_trigger(symbol, alert, current_candle, positions)
                                if trade_entry:
                                    positions[symbol] = trade_entry
                                    active_alerts.pop(symbol, None)
            
        print("\n--- Backtest Simulation Complete ---")
        self._generate_report()

    def _find_alert_candle(self, symbol, current_time):
        data = self.all_data[symbol]
        index = data.index.get_loc(current_time)
        candle = data.iloc[index]
        
        if self.config['trade_mode'] == 'positional' and candle.name.time().strftime('%H:%M') == self.config['trading_window_start']:
            return None
        
        prior_candle = data.iloc[index - 1]
        ema_value = prior_candle[f'ema_{self.config["ema_period"]}']
        
        direction = None
        trade_direction_cfg = self.config['trade_direction']
        if trade_direction_cfg in ['both', 'short_only'] and candle['low'] > ema_value: direction = 'SHORT'
        elif trade_direction_cfg in ['both', 'long_only'] and candle['high'] < ema_value: direction = 'LONG'
        
        if direction:
            reasons, confluence_count, filter_details = self._check_confluence(symbol, direction, index)
            if confluence_count >= self.config['min_confluence_filters']:
                return { "candle_time": candle.name, "direction": direction, "reasons": reasons }
        return None

    def _check_for_trigger(self, symbol, alert, current_candle, open_positions):
        alert_candle_data = self.all_data[symbol].loc[alert['candle_time']]
        if alert['direction'] == 'SHORT' and current_candle['low'] < alert_candle_data['low']:
            return self._open_trade(symbol, 'SHORT', current_candle, alert['candle_time'], alert['reasons'], open_positions)
        elif alert['direction'] == 'LONG' and current_candle['high'] > alert_candle_data['high']:
            return self._open_trade(symbol, 'LONG', current_candle, alert['candle_time'], alert['reasons'], open_positions)
        return None

    def _manage_open_trade(self, trade, prev_candle, current_candle):
        sl_cfg = self.config['stop_loss']
        if sl_cfg['use_atr_trail']: self._trail_sl_by_atr(trade, prev_candle)
        if sl_cfg['use_breakeven_stop'] and not trade['breakeven_triggered']: self._check_and_move_sl_to_breakeven(trade, current_candle)
        if trade['direction'] == 'SHORT':
            trade['highest_price_since_entry'] = max(trade['highest_price_since_entry'], current_candle['high'])
            trade['lowest_price_since_entry'] = min(trade['lowest_price_since_entry'], current_candle['low'])
        else:
            trade['highest_price_since_entry'] = max(trade['highest_price_since_entry'], current_candle['high'])
            trade['lowest_price_since_entry'] = min(trade['lowest_price_since_entry'], current_candle['low'])

    def _handle_overnight_gap(self, trade, current_candle):
        if trade['direction'] == 'SHORT' and current_candle['open'] >= trade['stop_loss']: return "SL Hit (Gap)"
        elif trade['direction'] == 'LONG' and current_candle['open'] <= trade['stop_loss']: return "SL Hit (Gap)"
        return None

    def _check_for_exit(self, trade, current_candle):
        if trade['direction'] == 'SHORT':
            if current_candle['high'] >= trade['stop_loss']: return "Trail SL Hit" if trade.get('is_sl_trailed', False) else "SL Hit"
            if current_candle['low'] <= trade['take_profit']: return "TP Hit"
        else:
            if current_candle['low'] <= trade['stop_loss']: return "Trail SL Hit" if trade.get('is_sl_trailed', False) else "SL Hit"
            if current_candle['high'] >= trade['take_profit']: return "TP Hit"
        if self.config['trade_mode'] == 'intraday' and current_candle.name.strftime('%H:%M') >= self.config['trading_window_end']: return "EOD Exit"
        return None

    def _check_confluence(self, symbol, direction, index):
        reasons, count, details = [], 0, {}
        candle = self.all_data[symbol].iloc[index]
        lookback = self.config.get('divergence_lookback', 30)
        recent_data = self.all_data[symbol].iloc[max(0, index - lookback):index+1]
        is_bearish_div = self._find_divergence(recent_data['high'], recent_data['rsi_14']) == "Bearish"
        is_bullish_div = self._find_divergence(recent_data['low'], recent_data['rsi_14']) == "Bullish"
        is_low_vol = candle['volume'] < candle['volume_20_sma']
        is_near_pdh = candle['low'] <= candle['prev_day_high'] <= candle['high']
        is_near_pdl = candle['low'] <= candle['prev_day_low'] <= candle['high']
        if direction == 'SHORT':
            if self.config['use_rsi_divergence']: details['RSI_Bearish_Div'] = is_bearish_div;
            if self.config['use_volume_profile']: details['Low_Alert_Volume'] = is_low_vol
            if self.config['use_static_sr']: details['Near_PDH'] = is_near_pdh
            if is_bearish_div: reasons.append("RSI_Bearish_Div"); count += 1
            if is_low_vol: reasons.append("Low_Alert_Volume"); count += 1
            if is_near_pdh: reasons.append("Near_PDH"); count += 1
        else:
            if self.config['use_rsi_divergence']: details['RSI_Bullish_Div'] = is_bullish_div
            if self.config['use_volume_profile']: details['Low_Alert_Volume'] = is_low_vol
            if self.config['use_static_sr']: details['Near_PDL'] = is_near_pdl
            if is_bullish_div: reasons.append("RSI_Bullish_Div"); count += 1
            if is_low_vol: reasons.append("Low_Alert_Volume"); count += 1
            if is_near_pdl: reasons.append("Near_PDL"); count += 1
        return reasons, count, details

    def _open_trade(self, symbol, direction, entry_candle, alert_candle_time, reasons, open_positions):
        alert_candle = self.all_data[symbol].loc[alert_candle_time]
        alert_candle_index = self.all_data[symbol].index.get_loc(alert_candle_time)
        candle_before_alert = self.all_data[symbol].iloc[alert_candle_index - 1]
        
        sl_cfg = self.config['stop_loss']
        slippage = self.config['transaction_costs']['slippage_points']
        entry_price = entry_candle['open'] + slippage if direction == 'LONG' else entry_candle['open'] - slippage
        
        min_sl_for_instrument = sl_cfg['minimum_sl_points'].get(symbol, 40.0)

        if direction == 'SHORT':
            stop_loss = max(alert_candle['high'], candle_before_alert['high']) if sl_cfg['use_two_candle_sl'] else alert_candle['high']
            risk_points = max(stop_loss - entry_price, min_sl_for_instrument)
            stop_loss = entry_price + risk_points
        else:
            stop_loss = min(alert_candle['low'], candle_before_alert['low']) if sl_cfg['use_two_candle_sl'] else alert_candle['low']
            risk_points = max(entry_price - stop_loss, min_sl_for_instrument)
            stop_loss = entry_price - risk_points

        ps_cfg = self.config['position_sizing']
        lot_size = self.config['instrument_details'][symbol]['lot_size']
        capital_base = self.equity if self.config.get('use_compounding', False) else self.config['initial_capital']
        capital_at_risk = capital_base * (ps_cfg['risk_per_trade_percent'] / 100)
        risk_per_contract = risk_points * lot_size
        
        if risk_per_contract <= 0: return None
        
        max_contracts = self.config['instrument_details'][symbol].get('max_contracts_per_trade', 100)
        num_contracts_calculated = math.floor(capital_at_risk / risk_per_contract)
        num_contracts = min(num_contracts_calculated, max_contracts)
        
        if num_contracts < 1: return None
            
        current_portfolio_risk = sum(pos['capital_at_risk'] for pos in open_positions.values())
        new_trade_risk_value = num_contracts * risk_per_contract
        max_total_risk = capital_base * (self.config['portfolio_risk']['max_portfolio_risk_percent'] / 100)
        
        if current_portfolio_risk + new_trade_risk_value > max_total_risk: return None

        take_profit = entry_price - (risk_points * self.config['risk_reward_ratio']) if direction == 'SHORT' else entry_price + (risk_points * self.config['risk_reward_ratio'])
        
        trade = {
            "symbol": symbol, "entry_time": entry_candle.name, "direction": direction, "entry_price": entry_price,
            "stop_loss": stop_loss, "take_profit": take_profit, "reasons": ", ".join(reasons),
            "initial_risk_points": risk_points, "num_contracts": num_contracts, "capital_at_risk": new_trade_risk_value,
            "highest_price_since_entry": entry_candle['high'], "lowest_price_since_entry": entry_candle['low'],
            "breakeven_triggered": False, "is_sl_trailed": False
        }
        return trade

    def _trail_sl_by_atr(self, trade, prev_candle):
        sl_cfg = self.config['stop_loss']
        atr_val = prev_candle.get(f"atr_{sl_cfg['atr_trail_period']}", 0)
        if pd.isna(atr_val) or atr_val == 0: return
        trail_amount = atr_val * sl_cfg['atr_trail_multiplier']
        if trade['direction'] == 'SHORT':
            new_sl = prev_candle['high'] - trail_amount
            if new_sl < trade['stop_loss']:
                trade['stop_loss'] = new_sl
                trade['is_sl_trailed'] = True
        else:
            new_sl = prev_candle['low'] + trail_amount
            if new_sl > trade['stop_loss']:
                trade['stop_loss'] = new_sl
                trade['is_sl_trailed'] = True

    def _check_and_move_sl_to_breakeven(self, trade, current_candle):
        costs = self.config['stop_loss']['breakeven_cost_assumption_points']
        buffer = self.config['stop_loss']['breakeven_profit_buffer_points']
        if trade['direction'] == 'LONG' and current_candle['close'] > trade['entry_price']:
            breakeven_price = trade['entry_price'] + costs + buffer
            if current_candle['close'] > breakeven_price:
                trade['stop_loss'] = max(trade['stop_loss'], breakeven_price)
                trade['breakeven_triggered'] = True
                trade['is_sl_trailed'] = True
        elif trade['direction'] == 'SHORT' and current_candle['close'] < trade['entry_price']:
            breakeven_price = trade['entry_price'] - costs - buffer
            if current_candle['close'] < breakeven_price:
                trade['stop_loss'] = min(trade['stop_loss'], breakeven_price)
                trade['breakeven_triggered'] = True
                trade['is_sl_trailed'] = True

    def _close_trade(self, trade, exit_candle, exit_reason, is_gap_exit=False):
        if is_gap_exit:
            exit_price = exit_candle['open']
        elif "SL Hit" in exit_reason:
            if trade['direction'] == 'LONG': exit_price = min(exit_candle['open'], trade['stop_loss'])
            else: exit_price = max(exit_candle['open'], trade['stop_loss'])
        elif exit_reason == "TP Hit": exit_price = trade['take_profit']
        else: exit_price = exit_candle['close']
        enhanced_log = self._create_enhanced_trade_log(trade, exit_candle, exit_price, exit_reason)
        self.trade_log.append(enhanced_log)
        if self.config.get('use_compounding', False):
            self.equity += enhanced_log['net_pnl_currency']
    
    def _create_enhanced_trade_log(self, trade, exit_candle, exit_price, exit_reason):
        lot_size = self.config['instrument_details'][trade['symbol']]['lot_size']
        if trade['initial_risk_points'] <= 0: mfe_R, mae_R = 0, 0
        elif trade['direction'] == 'SHORT':
            gross_pnl_pts = trade['entry_price'] - exit_price
            mfe_R = (trade['entry_price'] - trade['lowest_price_since_entry']) / trade['initial_risk_points']
            mae_R = (trade['highest_price_since_entry'] - trade['entry_price']) / trade['initial_risk_points']
        else:
            gross_pnl_pts = exit_price - trade['entry_price']
            mfe_R = (trade['highest_price_since_entry'] - trade['entry_price']) / trade['initial_risk_points']
            mae_R = (trade['entry_price'] - trade['lowest_price_since_entry']) / trade['initial_risk_points']
        
        costs_pts = self.config['transaction_costs']['cost_per_trade_points'].get(trade['symbol'], 1.5)
        
        adv_slippage_cfg = self.config.get('advanced_slippage', {})
        if adv_slippage_cfg.get('enabled', False):
            slippage_per_contract = adv_slippage_cfg.get('slippage_per_contract_points', 0)
            additional_slippage_cost = slippage_per_contract * trade['num_contracts']
            costs_pts += additional_slippage_cost
        net_pnl_pts = gross_pnl_pts - costs_pts
        net_pnl_currency = net_pnl_pts * trade['num_contracts'] * lot_size
        return {
            'symbol': trade['symbol'], 'entry_time': trade['entry_time'], 'exit_time': exit_candle.name, 'direction': trade['direction'],
            'entry_price': trade['entry_price'], 'exit_price': exit_price, 'stop_loss': trade['stop_loss'],
            'take_profit': trade['take_profit'], 'net_pnl_points': net_pnl_pts, 'net_pnl_currency': net_pnl_currency,
            'num_contracts': trade['num_contracts'], 'result': "Win" if net_pnl_currency > 0 else "Loss", 'exit_reason': exit_reason,
            'initial_risk_points': trade['initial_risk_points'], 'mfe_R': mfe_R, 'mae_R': mae_R,
            'reasons': trade['reasons']
        }

    def _generate_report(self):
        if not self.trade_log:
            print("\nNo trades were executed.")
            return
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        strategy_log_folder = os.path.join(self.config['log_folder'], self.config['strategy_name'], timestamp)
        os.makedirs(strategy_log_folder, exist_ok=True)
        log_df = pd.DataFrame(self.trade_log)
        if self.config['log_options']['log_trades']:
            trades_path = os.path.join(strategy_log_folder, f"{timestamp}_all_trades.csv")
            log_df.to_csv(trades_path, index=False)
            print(f"\nAggregated trade log saved to '{trades_path}'")
        
        initial_capital = self.config['initial_capital']
        if not log_df.empty:
            log_df['exit_date'] = pd.to_datetime(log_df['exit_time']).dt.date
            daily_pnl = log_df.groupby('exit_date')['net_pnl_currency'].sum()
            backtest_date_range = pd.date_range(start=self.master_dates[0].date(), end=self.master_dates[-1].date(), freq='B')
            daily_pnl = daily_pnl.reindex(backtest_date_range, fill_value=0)
            equity_curve = initial_capital + daily_pnl.cumsum()
            equity_df = equity_curve.to_frame(name='equity')
        else:
            equity_df = pd.DataFrame(columns=['equity'])

        total_trading_bars = len(self.master_dates)
        bars_in_market = 0
        if not log_df.empty:
            # Create a boolean series for when any position is open
            market_exposure = pd.Series(0, index=self.master_dates)
            for _, row in log_df.iterrows():
                market_exposure.loc[row['entry_time']:row['exit_time']] = 1
            bars_in_market = market_exposure.sum()
        time_in_market_pct = (bars_in_market / total_trading_bars) * 100 if total_trading_bars > 0 else 0

        total_trades = len(log_df)
        cagr, max_drawdown, sharpe_ratio = 0, 0, 0
        if not equity_df.empty and len(equity_df) > 1:
            years = (equity_df.index[-1] - equity_df.index[0]).days / 365.25
            final_equity = equity_df['equity'].iloc[-1]
            cagr = ((final_equity / initial_capital) ** (1 / years) - 1) * 100 if years > 0 else 0
            peak = equity_df['equity'].cummax()
            drawdown = (equity_df['equity'] - peak) / peak
            max_drawdown = abs(drawdown.min()) * 100
            daily_returns = equity_df['equity'].pct_change().dropna()
            if not daily_returns.empty and daily_returns.std() > 0:
                sharpe_ratio = (daily_returns.mean() / daily_returns.std()) * np.sqrt(252)
        
        winners = log_df[log_df['result'] == 'Win']
        losers = log_df[log_df['result'] == 'Loss']
        win_rate = (len(winners) / total_trades) * 100 if total_trades > 0 else 0
        total_net_pnl = log_df['net_pnl_currency'].sum()
        
        long_trades = log_df[log_df['direction'] == 'LONG']
        short_trades = log_df[log_df['direction'] == 'SHORT']
        long_pnl_pts = long_trades['net_pnl_points'].sum()
        short_pnl_pts = short_trades['net_pnl_points'].sum()
        long_win_rate = (len(long_trades[long_trades['result'] == 'Win']) / len(long_trades) * 100) if not long_trades.empty else 0
        short_win_rate = (len(short_trades[short_trades['result'] == 'Win']) / len(short_trades) * 100) if not short_trades.empty else 0
        
        final_equity_reported = initial_capital + total_net_pnl
        
        summary_text = f"""
BACKTEST PARAMETERS
======================================================
{format_config_for_summary(self.config)}

PERFORMANCE SUMMARY
======================================================
[Key Metrics]
  Net PnL: Rs.{total_net_pnl:,.2f}
  Final Equity: Rs.{final_equity_reported:,.2f}
  CAGR: {cagr:.2f}%
  Max Drawdown: {max_drawdown:.2f}%
  Sharpe Ratio: {sharpe_ratio:.2f}

[Trade Stats]
  Total Trades: {total_trades}
  Win Rate: {win_rate:.2f}%
  Time in Market: {time_in_market_pct:.2f}%

[Performance by Direction]
            |      LONG      |      SHORT
--------------------------------------------------
  Trades    | {len(long_trades):>12} | {len(short_trades):>12}
  Win Rate  | {long_win_rate:>11.2f}% | {short_win_rate:>11.2f}%
  PnL (pts) | {long_pnl_pts:>12,.2f} | {short_pnl_pts:>12,.2f}
"""
        print(summary_text)
        if self.config['log_options']['log_summary']:
            summary_path = os.path.join(strategy_log_folder, f"{timestamp}_all_trades.csv")
            with open(summary_path, 'w', encoding='utf-8') as f: f.write(summary_text)
            print(f"Summary report saved to '{summary_path}'")

if __name__ == "__main__":
    backtester = EMABacktester(CONFIG)
    backtester.run_backtest()
