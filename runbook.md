Project Runbook: Algorithmic Trading Strategy (Verbose Edition)Document Version: 2.0Date: 2025-07-20Objective: This document serves as the master operational guide for the Nifty 200 pullback trading strategy project. It provides a highly detailed, step-by-step process for data management, indicator calculation, and strategy backtesting. The procedures outlined here are designed to ensure consistent, repeatable, and verifiable results, assuming minimal prior knowledge of the system's day-to-day operations.1. System Architecture & PhilosophyThe project is designed as a modular data pipeline, where each script performs a distinct, specialized task. This separation of concerns is a core programming best practice that makes the system easier to manage, debug, and upgrade. The workflow is sequential and must be followed in order.1.1. Critical Files & DirectoriesThe system's stability depends on a precise folder and file structure./ (Root Project Directory)historical_data/: This is the repository for raw data. It contains the pristine, unprocessed daily OHLCV (Open, High, Low, Close, Volume) data exactly as it was downloaded from the Fyers API. No calculations or modifications should ever be made to files in this directory.data/processed/: This is the parent directory for processed data. It contains subdirectories for each timeframe, holding data that has been cleaned, resampled, and enriched with technical indicators.daily/2day/weekly/monthly/backtest_logs/: This is the output directory. All results from backtest runs, including summary reports (.txt) and detailed trade logs (.csv), are saved here. Each file is timestamped to prevent overwriting previous results.config.py: A critical configuration file that stores your private Fyers API credentials. This file should never be shared or committed to a public repository.fyers_access_token.txt: A temporary session file. It stores the active authentication token generated after a successful login, allowing scripts to make API calls without needing to re-authenticate every time. It has a limited lifespan (typically one day).nifty200.csv: The master list of stock symbols that defines the trading universe. The accuracy of this file is essential for the scrapers and backtesters.Python Scripts (*.py): The executable core of the project.1.2. The Script PipelineData Acquisition (fyers_..._scraper.py scripts): These scripts are the gateway to the market. Their sole responsibility is to communicate with the Fyers API and ensure the raw data in historical_data/ is complete and up-to-date.Indicator Calculation (calculate_indicators.py): This script is the data factory. It takes the raw data as input, transforms it by creating different timeframes (2-day, weekly, etc.), and enriches it by calculating all the technical indicators required by the strategy.Strategy Simulation (final_backtester.py, final_backtester_immediate.py): These are the decision-making engines. They consume the processed, indicator-rich data and simulate the trading strategy's logic day-by-day to generate performance metrics.2. Standard Operating Procedure (SOP) for a Backtest RunThis SOP is the standard workflow for running a backtest. It must be followed sequentially to ensure data integrity and the validity of the results.Step 1: Data Maintenance (Acquisition & Updates)Goal: To ensure your local raw dataset is synchronized with the latest available market data.Run the Equity Scraper: From your terminal, execute the following command:Bashpython fyers_equity_scraper.py
What it does: The script will read the list of symbols from nifty200.csv. For each symbol, it checks if a corresponding raw data file exists in historical_data/. If it does, it reads the last date in the file and only requests new data from that point forward. If the file doesn't exist, it downloads the full history. This incremental update process is highly efficient.Run the Index Scraper: Execute the command to update the Nifty 200 index data.Bashpython fyers_nifty200_index_scraper.py
What it does: This performs the same incremental update process but is specifically configured for the Nifty 200 index symbol.Verification: After these scripts complete successfully, check the "Date Modified" timestamp on the files within the historical_data/ directory. They should reflect the current date, indicating they have been updated.Step 2: Indicator Generation & ResamplingGoal: To process the newly acquired raw data and prepare it for the backtesters.Run the Indicator Script: Execute the following command from your terminal:Bashpython calculate_indicators.py
What it does: This script is a batch processor. It iterates through every raw data file in historical_data/. For each file, it performs two key operations:Resampling: It creates in-memory copies of the daily data for 2-day, weekly, and monthly timeframes by aggregating the daily candles.Calculation: It calculates all required indicators (EMAs, ATR, etc.) for all four timeframes.Saving: It saves the final, processed DataFrames as new .csv files into the appropriate subdirectories within data/processed/.Verification: Check the data/processed/ subdirectories. The files within should now have "Date Modified" timestamps reflecting the current run.Step 3: Backtest ConfigurationGoal: To precisely define the parameters for the simulation you wish to run.Choose Your Backtesting Engine:To test the standard, end-of-period strategy, open the final_backtester.py script.To test the accelerated, "fast entry" strategy, open the final_backtester_immediate.py script.Modify the config Dictionary: This dictionary at the top of the file is your central control panel. Edit the values directly in the script.'timeframe': Crucial. Defines which dataset to use.For final_backtester.py: 'daily', '2day', 'weekly', 'monthly'.For final_backtester_immediate.py: 'weekly-immediate', 'monthly-immediate'.'start_date' & 'end_date': Defines the exact period for the simulation.'risk_per_trade_percent': The percentage of total portfolio equity to risk on a single trade.'market_regime_filter': True to enable, False to disable. When enabled, it prevents new entries if the Nifty 200 is below its 50-day EMA.'volume_filter': True to enable, False to disable. When enabled, it requires entry day volume to be > 1.3x the 20-day average.'rs_filter': True to enable, False to disable. When enabled, it requires the stock's 30-day return to be greater than the Nifty 200's 30-day return.Step 4: Backtest Execution & ReviewGoal: To run the simulation and analyze the results.Execute the Backtester: Run the appropriate script from your terminal.Bash# For the standard strategy
python final_backtester.py
Monitor Progress: The script will print a single, updating line to the console, showing the date being processed, the current portfolio equity, and the number of open positions and total trades.Review the Summary Report: Once complete, a detailed summary report will be printed to the console and saved as a .txt file in backtest_logs/. This gives you the high-level performance metrics (CAGR, Drawdown, etc.).Analyze the Trade Log: A .csv file containing a detailed log of every single trade taken during the simulation will also be saved in backtest_logs/. This file is essential for the manual audit process.4. Manual Trade Audit Protocol (Verbose)This is the most critical oversight task. It is the definitive method for verifying the backtester's integrity.Scenario: You are auditing a trade for the symbol RELIANCE with an entry_date of 2024-05-15 from the trade log.[ ] Note the Key Details:Symbol: RELIANCEEntry Date: 2024-05-15[ ] Verify the Market Regime Filter:Action: Open data/processed/daily/NIFTY200_INDEX_daily_with_indicators.csv.Action: Find the row for the date 2024-05-15.Check: Compare the close and ema_50 columns. Let's say close is 21500.0 and ema_50 is 21200.0.Verdict: Since 21500.0 > 21200.0, the market was in an uptrend. The filter check passes.[ ] Verify the Relative Strength Filter:Action: In the same index file row, note the value in the return column. Let's say it is 3.5 (representing a 3.5% return over 30 periods).Action: Open data/processed/daily/RELIANCE_daily_with_indicators.csv.Action: Find the row for 2024-05-15 and note the value in its return column. Let's say it is 8.2.Verdict: Since the stock's return (8.2) is greater than the index's return (3.5), the stock was outperforming the market. The filter check passes.[ ] Verify the Volume Filter:Action: In the RELIANCE data file, on the 2024-05-15 row, find the volume and volume_ma columns. Let's say volume is 5,000,000 and volume_ma is 3,000,000.Check: Calculate the required volume: 3,000,000 * 1.3 = 3,900,000.Verdict: Since the actual volume (5,000,000) is greater than the required volume (3,900,000), the volume was strong enough. The filter check passes.[ ] Verify the Setup Pattern (on Day T-1):Action: In the RELIANCE data file, look at the row for the day before the entry: 2024-05-14.Check 1 (Green Candle): Is close > open? (Assume Yes).Check 2 (Bullish Candle): Is close > (high + low) / 2? (Assume Yes).Check 3 (Above EMA): Is close > ema_30? (Assume Yes).Check 4 (Preceded by Red): Look at the row for 2024-05-13. Is it a red candle (close < open)? (Assume Yes).Verdict: All setup conditions are met. The pattern check passes.[ ] Verify the Entry Trigger (on Day T):Action: Find the highest high of the pattern candles (e.g., the high of 2024-05-13 and 2024-05-14). Let's say the highest high was 2950.0. This is the trigger price.Action: Look at the open and high for the actual entry_date of 2024-05-15. Let's say open was 2940.0 and high was 2965.0.Verdict: Since the day's high (2965.0) is greater than the trigger price (2950.0) AND the day's open (2940.0) was below it, the entry was correctly triggered. The entry check passes.If all these checks pass, you have successfully and rigorously verified the integrity of that trade.