# analyze_hybrid_rogue_trades.py
#
# Description:
# This script provides a comprehensive performance analysis of the setups
# generated by the simulator_daily_hybrid.py. It categorizes all setups into
# two groups: "Subset" (also found by the benchmark) and "Unique" (rogue trades)
# and reports the full performance of each group.
#
# This allows for a direct comparison of the trades that align with the core
# strategy vs. those that arise from the simulator's unique timing.
#
# MODIFICATION V4 (Bug Fix):
# 1. Fixed a TypeError in the P&L simulation loop by removing the unsupported
#    `method='bfill'` argument from the `get_loc` function call.

import pandas as pd
import sys
import os

def simulate_trade_outcome(symbol, entry_date, entry_price, stop_loss, daily_data):
    """
    Simulates the outcome of a hypothetical trade.
    This logic should be kept consistent with the simulators.
    """
    if symbol not in daily_data or entry_date not in daily_data[symbol].index:
        return None, 0

    df = daily_data[symbol]
    target_price = entry_price + (entry_price - stop_loss)
    current_stop = stop_loss
    partial_exit_pnl, final_pnl, leg1_sold, exit_date = 0, 0, False, None
    
    trade_dates = df.loc[entry_date:].index[1:]
    for date in trade_dates:
        if date not in df.index: continue
        candle = df.loc[date]
        if not leg1_sold and candle['high'] >= target_price:
            partial_exit_pnl = target_price - entry_price
            leg1_sold = True
            current_stop = entry_price
        if candle['low'] <= current_stop:
            final_pnl = current_stop - entry_price
            exit_date = date
            break
        if candle['close'] > entry_price:
            current_stop = max(current_stop, entry_price)
            if candle['close'] > candle['open']: # green_candle
                current_stop = max(current_stop, candle['low'])

    if exit_date is None:
        exit_date = df.index[-1]
        final_pnl = df.iloc[-1]['close'] - entry_price

    total_pnl = (partial_exit_pnl * 0.5) + (final_pnl * 0.5) if leg1_sold else final_pnl
    return exit_date, total_pnl


def calculate_performance(df, name):
    """Calculates and prints a performance summary for a given dataframe of trades."""
    if df.empty:
        return {
            'name': name, 'total_trades': 0, 'net_pnl': 0, 'win_rate': 0,
            'profit_factor': 0, 'avg_win': 0, 'avg_loss': 0
        }

    net_pnl = df['pnl'].sum()
    winning_trades = df[df['pnl'] > 0]
    losing_trades = df[df['pnl'] <= 0]
    total_trades = len(df)
    win_rate = (len(winning_trades) / total_trades) * 100 if total_trades > 0 else 0
    gross_profit = winning_trades['pnl'].sum()
    gross_loss = abs(losing_trades['pnl'].sum())
    profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')
    avg_win = winning_trades['pnl'].mean() if len(winning_trades) > 0 else 0
    avg_loss = abs(losing_trades['pnl'].mean()) if len(losing_trades) > 0 else 0

    return {
        'name': name, 'total_trades': total_trades, 'net_pnl': net_pnl,
        'win_rate': win_rate, 'profit_factor': profit_factor,
        'avg_win': avg_win, 'avg_loss': avg_loss
    }

def print_report(stats):
    """Prints a formatted performance report."""
    print(f"\n--- Performance Summary of {stats['name']} ---")
    print("================================================")
    print(f"Total Setups / Trades:    {stats['total_trades']}")
    print(f"Net P&L (per share):      {stats['net_pnl']:,.2f}")
    print(f"Win Rate:                 {stats['win_rate']:.1f}%")
    print(f"Profit Factor:            {stats['profit_factor']:.2f}")
    print(f"Average Winning Trade:    {stats['avg_win']:,.2f}")
    print(f"Average Losing Trade:     {stats['avg_loss']:,.2f}")
    print("================================================")


def analyze_rogue_trades(benchmark_setups_file, hybrid_setups_file, hybrid_trades_file, daily_data_folder):
    """
    Identifies rogue trades and calculates their performance contribution.
    """
    print("--- Hybrid Simulator Comprehensive Trade Analysis ---")

    # --- 1. Validate inputs ---
    files = [benchmark_setups_file, hybrid_setups_file, hybrid_trades_file]
    for f in files:
        if not os.path.exists(f):
            print(f"\n[ERROR] File not found: {f}")
            sys.exit(1)
    if not os.path.isdir(daily_data_folder):
        print(f"\n[ERROR] Daily data folder not found: {daily_data_folder}")
        sys.exit(1)

    print(f"\nBenchmark Setups Log: {os.path.basename(benchmark_setups_file)}")
    print(f"Hybrid Setups Log:    {os.path.basename(hybrid_setups_file)}")
    print(f"Hybrid Trades Log:    {os.path.basename(hybrid_trades_file)}")

    # --- 2. Load logs ---
    benchmark_df = pd.read_csv(benchmark_setups_file)
    hybrid_setups_df = pd.read_csv(hybrid_setups_file)
    hybrid_trades_df = pd.read_csv(hybrid_trades_file)
    
    # --- 3. Load all daily data ---
    print("\nLoading daily data for hypothetical P&L calculation...")
    daily_data = {}
    for filename in os.listdir(daily_data_folder):
        if filename.endswith("_with_indicators.csv"):
            symbol = filename.replace("_daily_with_indicators.csv", "")
            try:
                df = pd.read_csv(os.path.join(daily_data_folder, filename), index_col='datetime', parse_dates=True)
                daily_data[symbol] = df
            except Exception as e:
                print(f"Warning: Could not load data for {symbol}. Error: {e}")
    print(f"Loaded data for {len(daily_data)} symbols.")

    # --- 4. Categorize Setups ---
    benchmark_setup_ids = set(benchmark_df['setup_id'].unique())
    hybrid_setup_ids = set(hybrid_setups_df['setup_id'].unique())

    unique_setup_ids = hybrid_setup_ids - benchmark_setup_ids
    subset_setup_ids = hybrid_setup_ids.intersection(benchmark_setup_ids)

    print("\n--- Setup Categorization ---")
    print(f"Total setups in Benchmark: {len(benchmark_setup_ids)}")
    print(f"Total setups in Hybrid Simulator: {len(hybrid_setup_ids)}")
    print(f" -> Unique (Rogue) Setups: {len(unique_setup_ids)}")
    print(f" -> Subset Setups: {len(subset_setup_ids)}")

    # --- 5. Analyze each group ---
    results = []
    for group_name, group_ids in [("Unique (Rogue) Trades", unique_setup_ids), ("Subset Trades", subset_setup_ids)]:
        if not group_ids: continue

        group_setups = hybrid_setups_df[hybrid_setups_df['setup_id'].isin(group_ids)]
        pnl_data = []

        for _, setup in group_setups.iterrows():
            setup_id = setup['setup_id']
            
            # Check if the trade was filled
            filled_trade = hybrid_trades_df[hybrid_trades_df['setup_id'] == setup_id]
            
            if not filled_trade.empty:
                # Use actual PnL for filled trades (summing up partial exits if any)
                pnl = filled_trade['pnl'].sum() / filled_trade.iloc[0]['initial_shares']
            else:
                # Simulate PnL for non-filled trades
                symbol = setup['symbol']
                entry_date = pd.to_datetime(setup['setup_date']) + pd.Timedelta(days=1)
                entry_price = setup['trigger_price']
                
                df = daily_data.get(symbol)
                if df is None: continue
                
                try:
                    # **BUG FIX**: Removed unsupported 'method' argument from get_loc
                    # The try/except block correctly handles cases where the date is not found.
                    loc = df.index.get_loc(entry_date)
                    stop_loss_lookback_start = loc - 5
                    stop_loss = df.iloc[max(0, stop_loss_lookback_start):loc]['low'].min()

                    if pd.notna(stop_loss):
                        _, pnl = simulate_trade_outcome(symbol, entry_date, entry_price, stop_loss, daily_data)
                    else:
                        pnl = 0
                except (KeyError, IndexError):
                    # This will catch cases where entry_date is a holiday/weekend
                    pnl = 0
            
            pnl_data.append({'setup_id': setup_id, 'pnl': pnl})

        results.append(calculate_performance(pd.DataFrame(pnl_data), group_name))

    # --- 6. Print final reports ---
    for res in results:
        print_report(res)

    print("\n--- Analysis Complete ---")


if __name__ == "__main__":
    # Corrected the argument count check to 5 (script name + 4 arguments)
    if len(sys.argv) != 5:
        print("\nUsage: python analyze_hybrid_rogue_trades.py <benchmark_setups.csv> <hybrid_setups.csv> <hybrid_trades_detail.csv> <path_to_daily_data_folder>")
        print("Example: python analyze_hybrid_rogue_trades.py logs/bench_setups.csv logs/hybrid_setups.csv logs/hybrid_trades.csv data/processed/daily")
        sys.exit(1)
        
    benchmark_log_path = sys.argv[1]
    hybrid_setups_path = sys.argv[2]
    hybrid_trades_path = sys.argv[3]
    daily_data_path = sys.argv[4]
    
    analyze_rogue_trades(benchmark_log_path, hybrid_setups_path, hybrid_trades_path, daily_data_path)
