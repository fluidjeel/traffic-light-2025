# daily_signal_characterizer.py
#
# Description:
# An analysis script that separates entry signals into "Winners" and "Losers"
# and then analyzes the characteristics of the EOD setup for each group.
# It calculates the average value of a comprehensive suite of indicators for
# both groups to find statistical differences for building new filters.
#
# MODIFICATION (v1.5 - Final Bug Fix):
# 1. FIXED: A critical bug where the script failed to look up indicator data for
#    setups occurring on non-trading days (holidays/weekends). The lookup now
#    correctly finds the last available trading day.
#
# MODIFICATION (v1.3 - Critical Bug Fix):
# 1. FIXED: A bug where indicator names in the analyzer did not match the actual
#    column names generated by the pandas_ta library.

import pandas as pd
import os
import sys
import numpy as np
from collections import Counter

# --- CONFIGURATION ---
config = {
    'log_folder': 'backtest_logs',
    'scanner_strategy_name': 'daily_entry_scanner',
    'scanner_output_filename': 'daily_entry_signals.csv',
    'processed_data_folder': os.path.join('data', 'universal_processed', 'daily'),
    'intraday_data_folder': os.path.join('data', 'universal_historical_data'),
    'index_symbol': 'NIFTY200_INDEX',

    'stop_loss_lookback_days': 3,
    'max_holding_days': 20,
    'win_threshold_r': 1.0, # A signal is a "Winner" if it achieves this R multiple
}

def get_signal_outcome(signal, daily_data, intraday_data, cfg):
    """Determines if a signal was a winner or a loser."""
    symbol = signal['symbol']
    entry_price = signal['trigger_price']
    entry_ts = signal['entry_timestamp']
    
    if symbol not in daily_data or symbol not in intraday_data: return None

    df_daily = daily_data[symbol]
    try:
        indexer = df_daily.index.get_indexer([entry_ts.date()], method='ffill')
        if indexer[0] == -1: return None
        entry_day_loc = indexer[0]
        
        stop_loss_slice = df_daily.iloc[max(0, entry_day_loc - cfg['stop_loss_lookback_days']) : entry_day_loc]
        if stop_loss_slice.empty: return None
        stop_loss_price = stop_loss_slice['low'].min()
    except (KeyError, IndexError): return None

    initial_risk = entry_price - stop_loss_price
    if initial_risk <= 0: return None

    win_target_price = entry_price + (initial_risk * cfg['win_threshold_r'])
    
    df_intraday = intraday_data[symbol]
    trade_horizon = df_intraday.loc[entry_ts : entry_ts + pd.Timedelta(days=cfg['max_holding_days'])]
    
    for _, candle in trade_horizon.iterrows():
        if candle['low'] <= stop_loss_price:
            return 'Loser' # Hit stop-loss
        if candle['high'] >= win_target_price:
            return 'Winner' # Hit profit target
    
    return 'Loser' # Timed out or did not hit target

def main():
    """Main function to run the characterization analysis."""
    print("--- Starting Daily Signal Characterization Analysis ---")

    cfg = config
    signals_filepath = os.path.join(cfg['log_folder'], cfg['scanner_strategy_name'], cfg['scanner_output_filename'])
    if not os.path.exists(signals_filepath):
        print(f"ERROR: Signals file not found. Run scanner first."); return
        
    signals_df = pd.read_csv(signals_filepath, parse_dates=['setup_date', 'entry_timestamp'])
    print(f"Loaded {len(signals_df)} entry signals.")

    print("Loading historical data...")
    daily_data, intraday_data = {}, {}
    symbols_to_load = signals_df['symbol'].unique().tolist() + [config['index_symbol']]
    for symbol in symbols_to_load:
        try:
            daily_file = os.path.join(cfg['processed_data_folder'], f"{symbol}_daily_with_indicators.csv")
            if os.path.exists(daily_file):
                df = pd.read_csv(daily_file, index_col='datetime', parse_dates=True)
                df.rename(columns=lambda x: x.lower().replace('.', '_'), inplace=True)
                daily_data[symbol] = df
            
            intraday_file = os.path.join(cfg['intraday_data_folder'], f"{symbol}_15min.csv")
            if os.path.exists(intraday_file):
                intraday_data[symbol] = pd.read_csv(intraday_file, index_col='datetime', parse_dates=True)
        except Exception as e:
            print(f"Warning: Could not load data for {symbol}. Error: {e}")
    print("Data loading complete.")

    print("Classifying signals as Winners vs. Losers...")
    signals_df['outcome'] = signals_df.apply(get_signal_outcome, axis=1, daily_data=daily_data, intraday_data=intraday_data, cfg=cfg)

    winners = signals_df[signals_df['outcome'] == 'Winner'].copy()
    losers = signals_df[signals_df['outcome'] == 'Loser'].copy()

    if winners.empty or losers.empty:
        print("\nCould not find both winners and losers to compare. Analysis cannot proceed.")
        return

    print(f"Found {len(winners)} Winners and {len(losers)} Losers.")

    # --- Analyze Characteristics ---
    characteristics = []
    indicators_to_check = [
        'ema_8', 'ema_20', 'ema_50', 'ema_100', 'ema_200',
        'rsi_14', 'macd_12_26_9', 'macdh_12_26_9', 'macds_12_26_9',
        'stochk_14_3_3', 'stochd_14_3_3', 'return_30',
        'atr_14_pct', 'bbu_20_2_0', 'bbm_20_2_0', 'bbl_20_2_0',
        'obv', 'volume_20_sma', 'volume_50_sma', 'volume',
        'prox_52w_high', 'body_ratio'
    ]
    
    index_df = daily_data[config['index_symbol']]

    for group_name, group_df in [('Winners', winners), ('Losers', losers)]:
        char_values = {indicator: [] for indicator in indicators_to_check + ['rs_vs_index']}
        
        for _, signal in group_df.iterrows():
            symbol = signal['symbol']
            setup_date = signal['setup_date']

            if symbol in daily_data:
                df_daily = daily_data[symbol]
                try:
                    ### BUG FIX: Use get_indexer to handle non-trading days ###
                    indexer = df_daily.index.get_indexer([setup_date], method='ffill')
                    if indexer[0] == -1:
                        continue
                    
                    setup_candle = df_daily.iloc[indexer[0]]
                    
                    for indicator in indicators_to_check:
                        if indicator in setup_candle and pd.notna(setup_candle[indicator]):
                            char_values[indicator].append(setup_candle[indicator])
                    
                    actual_setup_ts = setup_candle.name 
                    if actual_setup_ts in index_df.index and pd.notna(setup_candle['return_30']) and pd.notna(index_df.loc[actual_setup_ts, 'return_30']):
                        rs = setup_candle['return_30'] - index_df.loc[actual_setup_ts, 'return_30']
                        char_values['rs_vs_index'].append(rs)
                except (KeyError, IndexError):
                    continue

        avg_chars = {f"Avg {key}": np.mean(val) for key, val in char_values.items() if val}
        avg_chars['Group'] = group_name
        avg_chars['Count'] = len(group_df)
        characteristics.append(avg_chars)

    # --- Print Comparison Report ---
    print("\n--- Winner vs. Loser Characteristic Analysis (T-1 Setup Day) ---")
    report_df = pd.DataFrame(characteristics).set_index('Group')
    
    for col in report_df.columns:
        if 'pct' in col or 'prox' in col or 'return' in col or 'rs_vs' in col:
            report_df[col] = report_df[col].map('{:,.2f}%'.format)
        elif 'volume' in col or 'obv' in col:
            report_df[col] = report_df[col].map('{:,.0f}'.format)
        elif col != 'Count':
            report_df[col] = report_df[col].map('{:,.2f}'.format)
            
    print(report_df.T)
    print("\n--- Analysis Complete ---")

if __name__ == "__main__":
    main()
